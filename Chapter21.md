# Chapter 21 Linux System

* 본 장에서는 2003년도  Linux 2.6 커널에 대해 설명함

## 21.1 Linux 역사
* 1991년 리누즈 토발즈가 만듬
* 커널 영역과 시스템이 나뉘어서 개발됨
* 처음엔 80386 프로세서를 위해 만들어짐
  * 80386 프로세서 -> 최초의 진정한 32비트 처리기

### 21.1.1 리눅스 커널
* 0.0.1 ( 1991년 )
  * memory-mapped, 네트워크 기능이 없었음
  * device-driver, virtual-memory subsystem 기본적인 형태 사용
  * copy on write  기능을 가진 공유 페이지 기법을 사용
  * Minix 파일 시스템만을 지원
  * protected address space 를 가지고 있음
* 1.0 ( 1994년 )
  * 네트워크 기능
    * BSD 호환 소켓
    * TCP IP 네트워킹
    * IP를 실행하는 장치 구동기에 대한 지원
  * 사운드 카드
  * 마우스
  * 키보드
  * 플로피
  * CD ROM
  * 부동 소수점 에뮬레이션
  * 공유 메모리
  * 세마포
  * 메시지 큐
  * 프로세스 간 통신(IPC)
  * 동적 메모리 로드, 언로드 할 수 있는 커널 모듈
  * .1, .2 마이너 버전 개발
    * 홀수 -> 개발 중인 버전
    * 짝수 -> 안정화된 버전
* 1.2 ( 1995년 )
  * 새로운 PCI 하드웨어 버스 아키텍처
  * 네트워크 스택팅 갱신
  * 어카운팅
  * 방화벽
  * 기존 기능의 안정화를 추구함
* 2.0 ( 1996년 )
  * 여러개의 아키텍처 지원
  * 멀티 프로세스 아키텍처 지원
  * 파일 시스템 테이터의 단일화된 캐시 제공
  * memory-mapped region(쓰기 가능한 메모리 영역)
  * TCP/IP 성능 향상
  * 원격 네트워크 마운팅
* 2.2 ( 1999년 )
  * 방화벽 기능
  * 라우팅, 트래픽 관리
* 2.4, 2.6
  * SMP 시스템 지원 확대
  * 저널링 파일 시스템, 메모리 관리 시스템 성능 향상
  * (2.6) 프로세스 스케줄러의 개선
    * O(1) 복잡도
    * 선점 가능

### 21.1.2 Linux 시스템
* 커널 위에서 돌아갈 시스템(유틸)들 공동체에서 만들어서 배포

### 21.1.3 Linux 배포본
* 최초의 배포본
  * 적정 위치에 풀어 놓는 unpacking의 역활을 했음
* 개선된 배포본
  * 패키지 매니징 역활을 함
  * 많은 배포본들이 RPM 패키지 파일 포맷을 사용

### 21.1.4 Linux 저작권
* GNU General Public License
  * 무조건 실행 파일과 함께 소스코드도 공개 해야 한다.
* 소프트웨어에 대한 저작권은 포기하지만 소스코드에 대한 저작권은 가지고 있음

## 21.2 설계 원칙
* 다중 사용자
* 다중 작업 시스템
* 개인의 개발에 대한 열정으로 만들어졌기 때문에 개발자들이 자신들의 자원을 최대한 사용
  * 여전히 4mb 이하의 메모리에서도 돌릴 수 있음
* 빠른 속도
* 높은 효율
* 표준화
  * POSIX 표준 제공
    * 운영체제의 여러 측면에 관한 명세의 집함
      * POSIX 문서에는 운영체제의 기본적인 기능, 프로세스 스레드, 실시간 연산
* Linux 프로그래밍 인터페이스
  * BSD 보다는 SVR4쪽에 가까움

### 21.2.1 Linux 시스템의 구성요소
* Linux 커널 코드
  * 대부분의 전통적인 Unix 구현과 일치
  * **커널**
    * 가상 메모리, 프로세스를 다루는 곳
  * **시스템 라이브러리**
    * 응용 프로그램이 커널과 소통하는 함수를 정의
    * 커널 코드의 특권이 필요하지 않은 기능들을 구현한 함수
  * **시스템 유틸리티**
    * 개별적이고 특수한 관리기능을 실행하는 프로그램

* 커널 모드
  * 시스템의 모든 권한을 가지고 있는 모드(특권 모드)
  * 사용자 모드의 코드가 커널에 포함될 수 없음
  * 커널에서 반드시 동작해야 할 필요가 없는 코드들은 커널 밖의 시스템 라이브러리에 위치하게 됨

* 커널이 단일화된 실행 파일로 생성되는 형태를 유지
  * 성능 향상을 도모함
  * 모듈화에 대한 배려가 없다는 것을 뜻하진 않음

* 응용 -> 시스템 라이브러리 -> 커널

## 21.3 커널 모듈
* 새로운 드라이버만 따로 재컴파일 하여 이미 돌아가고 있는 커널에 로드 시킬 수 있음
* GPL에 의해 커널이 따로 분리되어 있으면 third party의 입장에서 자신들 만의 드라이버, 파일 시스템을 작성하여 배포하는 것이 가능

* **모듈관리 컴포넌트**
  * 모듈이 메모리에 로드되고 커널의 나머지 부분과 소통 할 수 있도록 하는 부분
* **장치 구동기 등록 컴포넌트**
  * 새로운 장치 구동기의 존재를 커널의 다른 부분에게 알려주는 부분
* **충돌 해결 컴포넌트**
  * 서로 다른 장치 구동기들이 하드웨어 자원을 예약하는 것을 도ㄷ와주고 자원을 서로 상충되게 사용하는 것을 막아주는 부분

### 21.3.1 모듈 관리
* 커널 주소 영역의 정확한 위치를 가리킬 수 있도록 모듈을 확실히 설정
  * 커널 심벌
  * 진입 지점

* 모듈을 작업하는 부분을 두 부분으로 나눔
  * 커널 메모리 상에서 모듈 코드 관리
  * 모듈이 참조하는 심벌을 다루는 일

* 심벌 테이블
  * https://ko.wikipedia.org/wiki/%EC%8B%AC%EB%B3%BC_%ED%85%8C%EC%9D%B4%EB%B8%94
  * 커널에 의해 명시적으로 export 되어야 함

* 모듈을 메모리에 등록 시키는 과정
  * 로더
    * 모듈을 위한 공간을 할당해 주도록 요청
  * 커널에게 export 하려고 하는 심벌 테이블을 모듈과 함께 커널에 전달

* 모듈 요청자
  * 모듈 관리 프로세스
    * 동적으로 로드된 모듈이 여전히 사용 중인지 체크
      * 사용되지 않는다면 unload

### 21.3.2 구동기 등록
* 등록 테이블이 포함하고 있는 것들은 아래와 같다
  * 장치 구동기
    * 드라이버를 말함
  * 파일 시스템
  * 네트워크 프로토콜
    * IPX 하나의 모듈이 전체적인 네트워크 프로토콜을 구현 할 수도 있고
    * 네트워크 방화벽을 위해 패킷을 걸러내는 규칙들만 구현 할 수 있다.
  * 이진 포맷

### 21.3.3 충돌 해결
* 상용 Unix의 경우 특정 판매자의 하드웨어에서만 작동
* 여러 모듈이 한 하드웨어 자원에 접근할 때 발생하는 충돌 방지
* 기존 장치 구동기 방해 방지
* 병렬 관리

## 21.4 프로세스 관리
* 프로세스 라는 문맥 속에서 처리

### 21.4.1 fork()/exec() 포르세스 모델
* 프로세스 생성
* 새로은 프로그램의 실행을 분리

* fork()
  * 새로운 프로세스 생성
* exec()
  * 새로운 프로그램 실행


#### 21.4.1.1 프로세스 식별
* 프로세스 ID ( PID )
* 신임장 ( Credentials )
* personality
  * 특정 시스템 호출할 때 의미를 제대로 전달하기 위해 해당 식별자를 가지고 있음(?)

#### 21.4.1.2 프로세스 환경
* 부모로 부터 상속 받게 됨
* 인자 벡터
  * 프로그램을 실행하는데 필요한 사용자 명령어 백터
* 환경 벡터
  * 이름=값

* 새로운 프로세스가 생성될때 변하지 않는다
  * 새로 생성된 자식 프로세스는 부모 프로세스의 환경을 그대로 상속
* 새로운 환경은 새로운 프로그램이 실행 될때 적용

#### 21.4.1.3 프로세스 문맥
* 프로세스의 식별, 프로세스 환경
  * 프로세스가 생성될 때 설정되는 것들

* 프로세스 문맥
  * 실행 중인 프로그램의 상태
  * 프로그램이 실행되는 동안 지속적으로 변화
  * 다음과 같은 것으로 이루어져있음
    * 스케줄링 문맥
      * 스케줄러가 프로세스를 보류 시키거나 재실행 시킬 때 필요한 정보
      * 해당 프로세스에 관련된 모든 레지스터 값
      * 우선순위
      * 프로세스에 정보가 전달되기를 기다리는 신호 관련
      * 커널 스택
        * 프로세스가 커널 모드에서 실행 될 때를 위해 사용하는 커널 메모리 영역
          * 프로세스마다 한 개씩 존재
      * 시스템 호출, 실행중인 인터럽트들은 이 스택을 사용
    * 회계
      * 사용하고 있는 자원과, 프로세스의 존속 기간
    * 파일 테이블
      * 커널 파일 구조를 가리키는 포인터 들의 리스트
    * 파일 시스템 문맥
      * 새로운 파일을 탐색하는 데 사용되는 디폴트 디렉토리
    * 신호 핸들러 테이블
      * 특정 신호가 도착했을 때 불릴 프로세스 주소 공간에 존재하는 루틴의 주소를 저장
    * 가상 메모리 문맥
      * 프로세스 주소 공간의 전체적인 내용을 기록

### 21.4.2 프로세스와 스레드
* clone()
  * 스레드를 생성
  * 사실 테스트라는 용어를 사용함
  * CLONE_FS
    * 파일 시스템 정보 공유
  * CLONE_VM
    * 동일한 메모리 공간 공유
  * CLONE_SIGHAND
    * 신호 처리기 공유
  * CLONE_FILES
    * 열린 파일 공유

* fork()
  * 공유를 사용하지 않고 복사본을 사용하는 clone의 특수한 경우

## 21.5 스케줄링

### 21.5.1 프로세스 스케줄링
* 시분할 알고리즘
  * 라운드 로빈
* 우선순위 알고리즘
  * 우선순위 큐
  * FCFS

### 21.5.2 커널 동기화
* 자신의 연산을 스케줄 하는 방법은 프로세스를 스케줄링 하는 방법과 근본적으로 다음

* 커널 모드 실행의 요청
  * 운영체제 서비스를 명시적으로 시스템 호출, 묵시적으로 요청
  * 장치 제어기는 하드웨어 인터럽트를 전달하여 그 인터럽트를 위해 커널에서 정의한 핸들러를 실행

* 여러 태스크들이 자료구조에 접근할 수 있다는 점
  * 커널 동기화는 단순한 프로세스 스케줄링 이상의 작업을 필요로 함

* 공유 데이터의 일관성을 해치지 않으면서 커널 태스크가 실행될 수 있는 framework가 필요함

* < 2.6
  * 비선점형 커널
    * 더 높은 우선순위의 태스크가 실행가능하더라도 실행 중인 프로세스는 선점 불가
* \>= 2.6
  * 선점형 커널
    * 커널에서 실행중일 때에도 태스크는 선점 가능
    * 스핀락
      * 임계 구역(critical section)에 진입이 불가능할 때 진입이 가능할 때까지 루프를 돌면서 재시도하는 방식으로 구현된 락
    * 세마포어
      *  재움 큐를 활용하여 프로세스를 재우는 방식

### 21.5.3 대칭형 다중처리
* 대칭형 다중처리(SMP)
* 여러개의 락으로 쪼갬
* 2.6
  * 처리기 진화성과 부하 균등 알고리즘

## 21.6 메모리 관리
* 물리 메모리
* 가상메모리

### 21.6.1 물리 메모리의 관리
* Linux는 물리 메모리를 세 종류의 zone 으로 구분
  * ZONE_DMA
    * 첫 물리 메모리
    * < 16MB
  * ZONE_NORMAL
    * CPU의 주소 공간에 맵핑되는 물리 메모리 구별
    * DMA가 접근할 수 있는 메모리를 제한하지 않는 시스템
      * ZONE_DMA non exist, ZONE_NORMAL 사용
    * 16....896MB
  * ZONE_HIGHMEM
    * 커널 주소 공간에 맵핑되지 않는 물리 메모리
    * \>= 896MB
* 용량은 32bit 기준

* 물리 메모리 관리자의 주 임무
  * 페이지 할당기
    * 버디 시스템
      * 인접한 할당 가능한 메모리 단위들을 함께 짝지어 주는데서 연유
      * 두 짝이 모두 반납 될 떄 마다 더 큰 영역이 됨

* kmalloc()
  * 일단 페이지를 할당하고 그 안에서 더 작은 부분으로 쪼개서 사용

* 슬랩 할당
  * 슬랩
    * 커널 자료구조를 할당하는데 사용
    * 하나 이상의 연속된 물리 페이지
    * 상태
      * Full
      * Empty (2순위)
      * Partial (1순위)
  * 캐시
    * 하나 이상의 슬랩
    * 커널 자료구조마다 하나의 캐시가 존재
  * 커널 객체를 저장하기 위해 캐시 사용

### 21.6.2 가상 메모리
* 가상 메모리 시스템
  * 각 프로세스에게 보이는 주소 공간을 관리
    * 요청 시 가상 메모리 페이지를 만들고 디스크로부터 페이지들을 로드
    * 다시 디스크로 방출하는 일

* 주소공간의 관점
  * 논리적인 관점
    * 주소공간의 배치에 관하여 가상 메모리 시스템이 전달 받은 지시사항들을 기술
    * 서로 겹쳐질 수 없는 영역의 집합
    * 연속적이면서 페이지 위치에 정렬된 주소 공간의 부분 집합
    * 내부적으로 영역의 특성을 정의하는 하나의 자료구조에 의해 기술
      * 균형 잡힌 이진트리로 연결되어 있음
    * 각 주소 공간의 물리적인 면을 유지
      * 프로세스의 하드웨어 페이지 테이블에 저장
      * 각 페이지 테이블 엔트리
        * 가상 메모리 상의 각 페이지들이 현존하는 위치정보를 결정

#### 21.6.2.1 가상 메모리 영역
* 가상 메모리 영역은 여러가지가 있음
* 이를 결정하는 요소
  1. 백업 저장 장소
    * 파일로 부터 오던지
      * 파일로 백업된 영역 = 해당 파일의 특정 부분
    * 아무데서도 오지 않던지
      * 요구 제로 메모리

#### 21.6.2.2 가상 주소 공간의 일생
* 새로운 가상 공간을 만드는 상황
  * exec()  -> 새 프로그램 코드를 실행할때
    * 빈 공간에 생성
  * fork() 새로운 프로세스를 실행할 때
    * 부모의 가상 주소 공간을 복사
      * 부모와 동일한 물리 메모리 페이지 공유

#### 21.6.2.3 스와핑과 페이징
* 스와핑
  * 물리 메모리에서 디스크로 옮기는 작업
* 페이징
  * 물리 메모리와 디스크 간의 이동을 가상 메모리의 페이지 단위
  * 알고리즘
    * 정책 알고리즘
      * 어떤,
      * 언제
    * 페이징 기법
      * 물리 -> 디스크 --(필요시)--> 물리

#### 21.6.2.4 커널 가상 메모리
* 보호 상태로 표시되어 사용자 모드에서는 이 영역에 접근 할 수 없음

* 정적 영역
  * 시스템 내의 가용 물리 메모리 페이지 각각에 대한 페이지 테이블 참조
  * 그 외의 영역

### 21.6.3 사용자 프로그램의 로딩과 실행
* exec
* 접근 권한 체크
* loader 호출
* 메모리에 맵핑

#### 21.6.3.1 프로그램을 메모리로 맵핑
* 가상 메모리에 맵핑된 후 사용중에 페이지 폴트 발생 시 메모리로 로드
  * 커널 이진 로더
    * 이러한 초기 메모리 맵핑 셋업 담당
    * ELF
      * 한 개의 헤더 와 여러 섹션들로 구성
      * 구조 ( 스택 , 힙 생각하면 쉬울 듯)

#### 21.6.3.2 정적 연결과 동적 연결
* 정적
  * 컴파일된 프로그램
* 동적
  * DLL

## 21.7 파일 시스템
* 여기서는 ext2fs 를 논의 함

### 21.7.1 가상 파일 시스템(VFS, The Virtual File System)
* 파일 시스템의 객체를 어떻게 보이게 할 것 인가
* 이 객체들을 실제로 처리하는 소프트 웨어 계층

* inode object
  * 각 개별 파일을 표현
  * 실제 파일의 내용을 담고 있는 디스크 블록의 포인터를 저장하는 자료구조
* file object
  * 열린 파일을 표현
  * 어느 위치를 프로세스가 읽거나 혹은 쓰고 있는지 추적
* superblock object   
  * 전체 파일 시스템
* dentry object
  * 개별적인 디렉터리 엔트리

### 21.7.2 Linux ext2fs 파일 시스템
* extfs
  * extended file system(extfs)
* ext2fs
  * second extended file system
  * 3단계 간접 블록 포인터 사용
  * 각 블록들을 연결 리스트로 구성
  * 다중 블록 그룹
    * 논리적으로 인접한 파일 블록들을 물리적으로 인접한 디스크 블록에 배치하는 정책 사용
  * 할당
    * 순환 검색 후 할당
    * 선할당 후 사용

### 21.7.3 저널링
* 저널링이란
  * 파일 시스템에 가해진 변경 사항들을 일지(journal)에 순차적으로 기록하는 기능
* 저널링의 목적
  * 시스템 장애시 저장장치 장애시 스토리지 복구 과정을 빠른 시간안에 처리 가능
* 저널링 단점
  * system call 수준에서만 일관성을 유지하기 때문에
  write()를 여러번 사용하는 도중 에러 발생 시 복사본이 원본보다 작을 수도 있다.

### 21.7.4 Linux Proc File System
* proc 파일 시스템
  * 일반 프로그램들을 하나의 텍스트 파일 다루듯이 사용할 수 있도록 해줌
  * 디렉터리 구조와 그 안의 파일 내용을 구현 해야함
  * 디렉토리, 파일 마다 영속적인 inode 번호를 유지해야함
  * pid = 16bit, inode object = 32bit
    * 이후 16bit는 프로세스의 타입 정보

## 21.8 입출력
* 블록 장치
  * 일반 적으로 파일 시스템을 저장하는데 사용
* 문자 장치
* 네트워크 장치

### 21.8.1 블록 장치
* 디스크 장치의 가장 중요한 인터페이스
  * 블럭 -> 메모리 -> 버퍼에 저장
* 요청관리자
  * 버퍼의 내용을 볼 수 있도록 장치 구동기로 읽고 쓰고 하는 소프트웨어 ㅊ층
* 읽기 큐
* 쓰기 큐

### 21.8.2 문자 장치
* 스트림
* 버퍼
* 회선 규범
  * 터미널 장치로 부터 오는 정보를 해석해주는 모듈

## 21.9 프로세스 간 통신

### 21.9.1 동기화와 신호
* 신호(signal)
  * kill 신호 생각하면 무슨 느낌인지 알듯?
### 21.9.2 프로세스들 사이의 데이터 전달

## 21.10 네트워크 구조
* 소켓 인터페이스
* 프로ㅌ콜 드라이버
* 네트워크 장치 구동기

## 21.11 보안
* 인증
* 접근 제어

### 21.11.1 인증
* PAM

### 21.11.2 접근 제어
* 사용자 권한
* 그룹 권한
* 일반 권한
* 루트
* setuid
* chown 생각하면 쉬울듯
